from django.shortcuts import render
from rest_framework import viewsets, status, generics, permissions
from rest_framework.decorators import action, api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from django.db.models import Sum, Avg, F, Q
from django.utils import timezone
from datetime import datetime, timedelta
from .models import (
    CarbonSource,
    CarbonOffsetAction,
    CarbonEntry,
    CarbonCertification,
    CarbonBenchmark,
    CarbonReport,
    CarbonAuditLog,
    SustainabilityBadge,
    MicroOffset,
    GreenPoints,
    CarbonOffsetProject,
    CarbonOffsetPurchase,
    CarbonOffsetCertificate,
    IoTDevice,
    IoTDataPoint,
    AutomationRule,
)
from history.models import WeatherEvent, ChemicalEvent, ProductionEvent, GeneralEvent
from .serializers import (
    CarbonSourceSerializer,
    CarbonOffsetActionSerializer,
    CarbonEntrySerializer,
    CarbonCertificationSerializer,
    CarbonBenchmarkSerializer,
    CarbonReportSerializer,
    CarbonFootprintSummarySerializer,
    SustainabilityBadgeSerializer,
    MicroOffsetSerializer,
    GreenPointsSerializer,
    CarbonAuditLogSerializer,
    CarbonOffsetProjectSerializer,
    CarbonOffsetPurchaseSerializer,
    CarbonOffsetCertificateSerializer
)
from .services import coolfarm_service
from .services.cost_optimizer import CostOptimizer
from django.contrib.auth import get_user_model
from company.models import Establishment
from history.models import History
from .services.calculator import calculator
from .services.verification import verification_service
from .services.certificate import certificate_generator
from .services.report_generator import report_generator
from rest_framework import serializers
import logging

logger = logging.getLogger(__name__)
User = get_user_model()

# Custom permission for company admin/manager
class IsCompanyAdminOrManager(permissions.BasePermission):
    def has_permission(self, request, view):
        return request.user and request.user.is_authenticated and request.user.role in ['admin', 'manager']

# Custom permission to check for premium subscription
class IsPremiumUser(permissions.BasePermission):
    def has_permission(self, request, view):
        # Placeholder logic for checking subscription status
        # In a real implementation, this would check against a subscription model or service
        if not hasattr(request.user, 'subscription_plan'):
            return False
        return request.user.subscription_plan in ['premium', 'enterprise']

class CarbonSourceViewSet(viewsets.ModelViewSet):
    queryset = CarbonSource.objects.all()
    serializer_class = CarbonSourceSerializer

class CarbonOffsetActionViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = CarbonOffsetAction.objects.all()
    serializer_class = CarbonOffsetActionSerializer
    permission_classes = []  # Public

class CarbonEntryViewSet(viewsets.ModelViewSet):
    queryset = CarbonEntry.objects.all()
    serializer_class = CarbonEntrySerializer

    def get_queryset(self):
        user = self.request.user
        if not user.is_authenticated:
            return CarbonEntry.objects.none()
        
        queryset = CarbonEntry.objects.all()
        
        # Apply filters from query parameters
        establishment_id = self.request.query_params.get('establishment')
        production_id = self.request.query_params.get('production')
        year = self.request.query_params.get('year')
        
        if establishment_id:
            try:
                establishment_id = int(establishment_id)
                queryset = queryset.filter(establishment_id=establishment_id)
            except (ValueError, TypeError):
                pass
                
        if production_id:
            try:
                production_id = int(production_id)
                queryset = queryset.filter(production_id=production_id)
            except (ValueError, TypeError):
                pass
                
        if year:
            try:
                year = int(year)
                queryset = queryset.filter(year=year)
            except (ValueError, TypeError):
                pass
                
        return queryset

    @action(detail=False, methods=['post'])
    def calculate_emissions(self, request):
        """
        Calculate emissions using CoolFarmTool API
        """
        try:
            crop_type = request.data.get('crop_type')
            acreage = float(request.data.get('acreage', 0))
            inputs = request.data.get('inputs', {})
            region = request.data.get('region')

            if not crop_type or acreage <= 0:
                return Response(
                    {'error': 'Invalid crop type or acreage'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            # Calculate emissions using CoolFarmTool service
            result = coolfarm_service.calculate_emissions(
                crop_type=crop_type,
                acreage=acreage,
                inputs=inputs,
                region=region
            )

            return Response(result)

        except ValueError as e:
            return Response(
                {'error': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
        except Exception as e:
            return Response(
                {'error': 'Failed to calculate emissions'},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    @action(detail=False, methods=['post'])
    def bulk_create(self, request):
        entries = request.data
        if not isinstance(entries, list):
            return Response({'error': 'Expected a list of entries'}, status=status.HTTP_400_BAD_REQUEST)

        serializer = self.get_serializer(data=entries, many=True)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    @action(detail=False, methods=['get'])
    def by_entity(self, request):
        entity_type = request.query_params.get('entity_type')
        entity_id = request.query_params.get('entity_id')
        if entity_type not in ['establishment', 'production'] or not entity_id:
            return Response({'error': 'Invalid entity type or ID'}, status=status.HTTP_400_BAD_REQUEST)

        if entity_type == 'establishment':
            entries = CarbonEntry.objects.filter(establishment_id=entity_id)
        else:  # production
            entries = CarbonEntry.objects.filter(production_id=entity_id)

        page = self.paginate_queryset(entries)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(entries, many=True)
        return Response(serializer.data)

    def perform_create(self, serializer):
        # Check if the entry is for production-level tracking and restrict to premium users
        if serializer.validated_data.get('production') and (not hasattr(self.request.user, 'subscription_plan') or self.request.user.subscription_plan not in ['premium', 'enterprise']):
            raise permissions.PermissionDenied(detail='Production-level tracking is a premium feature. Upgrade your plan.')
        
        # If raw_amount is provided, calculate emissions using CoolFarmTool
        raw_amount = self.request.data.get('raw_amount')
        if raw_amount is not None:
            try:
                crop_type = self.request.data.get('crop_type')
                acreage = float(raw_amount)
                inputs = self.request.data.get('inputs', {})
                region = self.request.data.get('region')

                if crop_type:
                    result = coolfarm_service.calculate_emissions(
                        crop_type=crop_type,
                        acreage=acreage,
                        inputs=inputs,
                        region=region
                    )
                    serializer.validated_data['amount'] = result['co2e']
                    serializer.validated_data['usda_verified'] = result['usda_verified']
            except Exception as e:
                # Log error but continue with creation
                logger.error(f"Error calculating emissions: {e}")

        serializer.save(created_by=self.request.user)
        # Log the creation
        CarbonAuditLog.objects.create(
            carbon_entry=serializer.instance,
            user=self.request.user,
            action='create',
            details=f'Created {serializer.instance.type} entry'
        )

    def perform_update(self, serializer):
        serializer.save()
        # Log the update
        CarbonAuditLog.objects.create(
            carbon_entry=serializer.instance,
            user=self.request.user,
            action='update',
            details=f'Updated {serializer.instance.type} entry'
        )

    def perform_destroy(self, instance):
        # Log the deletion
        CarbonAuditLog.objects.create(
            carbon_entry=instance,
            user=self.request.user,
            action='delete',
            details=f'Deleted {instance.type} entry'
        )
        instance.delete()

    @action(detail=False, methods=['get'])
    def summary(self, request):
        establishment_id = request.query_params.get('establishment')
        production_id = request.query_params.get('production')
        year = request.query_params.get('year', timezone.now().year)

        if not establishment_id and not production_id:
            return Response({'error': 'Either establishment or production ID is required'}, status=status.HTTP_400_BAD_REQUEST)

        if production_id and (not hasattr(request.user, 'subscription_plan') or request.user.subscription_plan not in ['premium', 'enterprise']):
            return Response({'error': 'Production-level tracking is a premium feature. Upgrade your plan.'}, status=status.HTTP_403_FORBIDDEN)

        queryset = CarbonEntry.objects.all()
        if establishment_id:
            queryset = queryset.filter(establishment_id=establishment_id)
        if production_id:
            queryset = queryset.filter(production_id=production_id)
        queryset = queryset.filter(year=year)

        total_emissions = queryset.filter(type='emission').aggregate(Sum('amount'))['amount__sum'] or 0
        total_offsets = queryset.filter(type='offset').aggregate(Sum('amount'))['amount__sum'] or 0
        net_carbon = total_emissions - total_offsets
        
        # Calculate carbon score (0-100 scale)
        carbon_score = 0
        if total_emissions > 0:
            # Base score on offset percentage with diminishing returns
            offset_percentage = min(100, (total_offsets / total_emissions) * 100)
            
            # Score increases with percentage of offsets
            if offset_percentage >= 100:
                carbon_score = 85  # Base score for carbon neutrality
                # Bonus for going beyond neutrality
                carbon_score += min(15, ((offset_percentage - 100) / 50) * 15)
            else:
                carbon_score = offset_percentage * 0.85  # Scale up to 85 max
        
        # Get industry benchmark if available
        industry_benchmark = 0
        if establishment_id:
            try:
                establishment = Establishment.objects.get(id=establishment_id)
                # Try to use industry attribute if it exists, otherwise fall back to type
                industry = None
                if hasattr(establishment, 'industry') and establishment.industry:
                    industry = establishment.industry
                elif establishment.type:
                    industry = establishment.type
                
                if industry:
                    try:
                        benchmark = CarbonBenchmark.objects.filter(
                            industry=industry,
                            year=year
                        ).first()
                        if benchmark:
                            industry_benchmark = benchmark.average_emissions
                    except Exception:
                        pass
            except Establishment.DoesNotExist:
                pass
                
        # Return consistent field names for frontend
        summary_data = {
            'total_emissions': total_emissions,
            'total_offsets': total_offsets,
            'net_carbon': net_carbon,
            'carbon_score': round(carbon_score),
            'industry_average': industry_benchmark
        }
        
        return Response(summary_data)


# ROI Calculation and Cost Optimization Endpoints
class CostOptimizationViewSet(viewsets.ViewSet):
    """
    ViewSet for cost optimization and ROI calculation services.
    Provides savings analysis and recommendations for agricultural operations.
    """
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=False, methods=['post'], url_path='calculate-savings')
    def calculate_savings(self, request):
        """
        Calculate comprehensive savings potential for an establishment.
        Expected payload: {'establishment_id': int}
        """
        try:
            establishment_id = request.data.get('establishment_id')
            
            if not establishment_id:
                return Response(
                    {'error': 'establishment_id is required'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Verify establishment exists
            try:
                establishment = Establishment.objects.get(id=establishment_id)
            except Establishment.DoesNotExist:
                return Response(
                    {'error': 'Establishment not found'}, 
                    status=status.HTTP_404_NOT_FOUND
                )
            
            # Initialize cost optimizer and calculate savings
            optimizer = CostOptimizer()
            savings_analysis = optimizer.calculate_savings_potential(establishment_id)
            
            # Log the analysis for audit trail
            CarbonAuditLog.objects.create(
                user=request.user,
                action='create',
                details=f'Generated savings analysis for establishment {establishment_id}'
            )
            
            return Response(savings_analysis, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f"Error calculating savings potential: {str(e)}")
            return Response(
                {
                    'error': 'Failed to calculate savings potential',
                    'details': str(e),
                    'total_annual_savings': 0,
                    'recommendations': []
                }, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    @action(detail=False, methods=['get'], url_path='equipment-marketplace')
    def equipment_marketplace(self, request):
        """
        Get equipment marketplace recommendations based on current usage patterns.
        Query params: establishment_id (required)
        """
        try:
            establishment_id = request.query_params.get('establishment_id')
            
            if not establishment_id:
                return Response(
                    {'error': 'establishment_id query parameter is required'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            try:
                establishment = Establishment.objects.get(id=establishment_id)
            except Establishment.DoesNotExist:
                return Response(
                    {'error': 'Establishment not found'}, 
                    status=status.HTTP_404_NOT_FOUND
                )
            
            # Mock equipment marketplace data (replace with real marketplace integration)
            equipment_recommendations = [
                {
                    'id': 'tractor_upgrade_2024',
                    'category': 'tractor',
                    'title': 'Fuel-Efficient Compact Tractor',
                    'brand': 'John Deere 3038E',
                    'description': 'Modern compact tractor with 30% better fuel efficiency',
                    'current_cost': 18000,
                    'annual_savings': 1200,
                    'payback_months': 18,
                    'efficiency_improvement': '30%',
                    'features': [
                        'Advanced fuel injection system',
                        'Precision steering and GPS ready',
                        'Reduced maintenance requirements',
                        'IoT connectivity for tracking'
                    ],
                    'financing_options': [
                        {'type': 'lease', 'monthly_payment': 320, 'term_months': 60},
                        {'type': 'loan', 'monthly_payment': 285, 'term_months': 72, 'interest_rate': 4.5}
                    ],
                    'carbon_impact': {
                        'co2_reduction_annually': 2.4,  # tons
                        'efficiency_score_improvement': 25
                    }
                },
                {
                    'id': 'irrigation_system_2024',
                    'category': 'irrigation',
                    'title': 'Smart Drip Irrigation System',
                    'brand': 'Rain Bird XFS Subsurface',
                    'description': 'Precision irrigation with soil moisture sensors',
                    'current_cost': 8500,
                    'annual_savings': 800,
                    'payback_months': 13,
                    'efficiency_improvement': '40%',
                    'features': [
                        'Soil moisture monitoring',
                        'Weather-based scheduling',
                        'Mobile app control',
                        'Water usage analytics'
                    ],
                    'financing_options': [
                        {'type': 'rebate', 'discount_amount': 2000, 'program': 'USDA Water Conservation'},
                        {'type': 'loan', 'monthly_payment': 180, 'term_months': 48, 'interest_rate': 3.9}
                    ],
                    'carbon_impact': {
                        'co2_reduction_annually': 1.8,
                        'efficiency_score_improvement': 20
                    }
                },
                {
                    'id': 'sprayer_upgrade_2024',
                    'category': 'sprayer',
                    'title': 'Precision Chemical Applicator',
                    'brand': 'Apache AS1240',
                    'description': 'Variable rate technology for reduced chemical waste',
                    'current_cost': 45000,
                    'annual_savings': 3500,
                    'payback_months': 15,
                    'efficiency_improvement': '35%',
                    'features': [
                        'Variable rate technology',
                        'GPS section control',
                        'Real-time application monitoring',
                        'Reduced chemical waste'
                    ],
                    'financing_options': [
                        {'type': 'lease', 'monthly_payment': 850, 'term_months': 60},
                        {'type': 'trade_in', 'trade_value': 12000, 'net_cost': 33000}
                    ],
                    'carbon_impact': {
                        'co2_reduction_annually': 4.2,
                        'efficiency_score_improvement': 30
                    }
                }
            ]
            
            return Response({
                'establishment_id': establishment_id,
                'marketplace_updated': timezone.now().isoformat(),
                'equipment_recommendations': equipment_recommendations,
                'financing_programs': [
                    {
                        'name': 'USDA Rural Development Loan',
                        'description': 'Low-interest loans for agricultural equipment',
                        'max_amount': 100000,
                        'interest_rate': 3.5,
                        'term_years': 10
                    },
                    {
                        'name': 'Farm Service Agency Equipment Loan',
                        'description': 'Government-backed loans for qualifying farmers',
                        'max_amount': 200000,
                        'interest_rate': 4.0,
                        'term_years': 15
                    }
                ],
                'rebate_programs': [
                    {
                        'name': 'Environmental Quality Incentives Program (EQIP)',
                        'description': 'Cost-share assistance for conservation practices',
                        'max_rebate': 0.75,  # 75% cost share
                        'eligible_categories': ['irrigation', 'conservation_tillage', 'nutrient_management']
                    }
                ]
            }, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f"Error fetching equipment marketplace: {str(e)}")
            return Response(
                {
                    'error': 'Failed to fetch equipment marketplace data',
                    'details': str(e),
                    'equipment_recommendations': []
                }, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    @action(detail=False, methods=['post'], url_path='bulk-purchasing')
    def bulk_purchasing_opportunities(self, request):
        """
        Analyze bulk purchasing opportunities for chemical inputs.
        Expected payload: {'establishment_ids': [int], 'chemical_types': [str]}
        """
        try:
            establishment_ids = request.data.get('establishment_ids', [])
            chemical_types = request.data.get('chemical_types', ['FE', 'PE', 'HE', 'FU'])
            
            if not establishment_ids:
                return Response(
                    {'error': 'establishment_ids is required'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Aggregate chemical usage across establishments
            total_usage = {}
            total_cost = 0
            
            for establishment_id in establishment_ids:
                try:
                    establishment = Establishment.objects.get(id=establishment_id)
                    productions = History.objects.filter(parcel__establishment=establishment)
                    
                    for production in productions:
                        chemical_events = ChemicalEvent.objects.filter(
                            history=production,
                            type__in=chemical_types
                        )
                        
                        for event in chemical_events:
                            chemical_type = event.type
                            if chemical_type not in total_usage:
                                total_usage[chemical_type] = {
                                    'volume': 0,
                                    'estimated_cost': 0,
                                    'events_count': 0
                                }
                            
                            # Extract volume and estimate cost
                            optimizer = CostOptimizer()
                            volume = optimizer._extract_numeric_value(event.volume or "0")
                            cost = optimizer._estimate_chemical_cost_from_event(event)
                            
                            total_usage[chemical_type]['volume'] += volume
                            total_usage[chemical_type]['estimated_cost'] += cost
                            total_usage[chemical_type]['events_count'] += 1
                            total_cost += cost
                            
                except Establishment.DoesNotExist:
                    continue
            
            # Calculate bulk discounts and savings opportunities
            bulk_opportunities = []
            total_potential_savings = 0
            
            for chemical_type, usage_data in total_usage.items():
                if usage_data['estimated_cost'] > 1000:  # Minimum threshold for bulk pricing
                    chemical_name = dict(ChemicalEvent.CHEMICAL_EVENTS)[chemical_type]
                    
                    # Calculate bulk discount (15-20% for large orders)
                    bulk_discount = 0.18 if usage_data['estimated_cost'] > 5000 else 0.12
                    potential_savings = usage_data['estimated_cost'] * bulk_discount
                    total_potential_savings += potential_savings
                    
                    bulk_opportunities.append({
                        'chemical_type': chemical_type,
                        'chemical_name': chemical_name,
                        'total_volume': usage_data['volume'],
                        'total_cost': usage_data['estimated_cost'],
                        'events_count': usage_data['events_count'],
                        'bulk_discount_percentage': bulk_discount * 100,
                        'potential_savings': potential_savings,
                        'recommended_suppliers': [
                            {
                                'name': 'AgriSupply Co-op',
                                'discount': bulk_discount,
                                'minimum_order': 5000,
                                'delivery_included': True,
                                'contact': 'bulk@agrisupply.com'
                            },
                            {
                                'name': 'Farm Chemical Direct',
                                'discount': bulk_discount - 0.02,
                                'minimum_order': 3000,
                                'delivery_included': False,
                                'contact': '1-800-FARM-CHEM'
                            }
                        ]
                    })

            return Response({
                'analysis_date': timezone.now().isoformat(),
                'establishments_analyzed': len(establishment_ids),
                'total_annual_cost': total_cost,
                'total_potential_savings': total_potential_savings,
                'savings_percentage': (total_potential_savings / max(total_cost, 1)) * 100,
                'bulk_opportunities': bulk_opportunities,
                'coordination_tips': [
                    'Contact neighboring farms to increase order volumes',
                    'Plan seasonal chemical needs 3-6 months in advance',
                    'Ensure proper storage facilities for bulk orders',
                    'Consider shared storage and delivery arrangements'
                ]
            }, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f"Error analyzing bulk purchasing: {str(e)}")
            return Response(
                {
                    'error': 'Failed to analyze bulk purchasing opportunities',
                    'details': str(e),
                    'bulk_opportunities': []
                }, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    @action(detail=False, methods=['get'], url_path='government-incentives')
    def government_incentives(self, request):
        """
        Get available government incentives and grants for sustainability practices.
        Query params: establishment_id, location (optional)
        """
        try:
            establishment_id = request.query_params.get('establishment_id')
            location = request.query_params.get('location', 'US')  # Default to US
            
            # Mock government incentives data (replace with real government API integration)
            incentives = [
                {
                    'id': 'eqip_2024',
                    'program': 'Environmental Quality Incentives Program (EQIP)',
                    'agency': 'USDA NRCS',
                    'type': 'cost_share',
                    'max_payment': 200000,
                    'cost_share_percentage': 75,
                    'eligible_practices': [
                        'Cover crop',
                        'Nutrient management',
                        'Integrated pest management',
                        'Conservation tillage',
                        'Irrigation water management'
                    ],
                    'application_deadline': '2024-03-15',
                    'application_status': 'open',
                    'estimated_approval_time': '90 days',
                    'contact_info': {
                        'office': 'Local NRCS Office',
                        'phone': '1-800-NRCS-HELP',
                        'website': 'https://www.nrcs.usda.gov/programs-initiatives/eqip'
                    }
                },
                {
                    'id': 'csp_2024',
                    'program': 'Conservation Stewardship Program (CSP)',
                    'agency': 'USDA NRCS',
                    'type': 'annual_payment',
                    'max_payment': 40000,
                    'payment_structure': 'per_acre_per_year',
                    'eligible_practices': [
                        'Carbon sequestration',
                        'Soil health improvement',
                        'Water quality protection',
                        'Wildlife habitat enhancement'
                    ],
                    'contract_length': '5 years',
                    'application_deadline': '2024-02-28',
                    'application_status': 'open',
                    'estimated_approval_time': '120 days',
                    'contact_info': {
                        'office': 'Local NRCS Office',
                        'phone': '1-800-NRCS-HELP',
                        'website': 'https://www.nrcs.usda.gov/programs-initiatives/csp'
                    }
                },
                {
                    'id': 'carbon_credit_2024',
                    'program': 'Climate Smart Agriculture Carbon Credits',
                    'agency': 'Private Market / USDA Partnership',
                    'type': 'market_payment',
                    'payment_rate': '15-30 per ton CO2e',
                    'eligible_practices': [
                        'No-till farming',
                        'Cover crops',
                        'Rotational grazing',
                        'Agroforestry'
                    ],
                    'contract_length': '10 years',
                    'verification_required': True,
                    'application_status': 'continuous',
                    'estimated_approval_time': '60 days',
                    'contact_info': {
                        'program': 'Nori Carbon Markets',
                        'website': 'https://nori.com',
                        'email': 'farmers@nori.com'
                    }
                },
                {
                    'id': 'reap_2024',
                    'program': 'Rural Energy for America Program (REAP)',
                    'agency': 'USDA Rural Development',
                    'type': 'grant_loan',
                    'max_grant': 500000,
                    'max_loan': 25000000,
                    'grant_percentage': 25,
                    'eligible_technologies': [
                        'Solar panels',
                        'Wind turbines',
                        'Biomass systems',
                        'Energy efficiency improvements'
                    ],
                    'application_deadline': '2024-04-30',
                    'application_status': 'open',
                    'estimated_approval_time': '180 days',
                    'contact_info': {
                        'office': 'USDA Rural Development',
                        'phone': '1-800-RD-APPLY',
                        'website': 'https://www.rd.usda.gov/programs-services/energy-programs/rural-energy-america-program-renewable-energy-systems-energy-efficiency-improvement-grants'
                    }
                }
            ]
            
            # Filter incentives based on establishment characteristics if available
            if establishment_id:
                try:
                    establishment = Establishment.objects.get(id=establishment_id)
                    # Add establishment-specific filtering logic here
                except Establishment.DoesNotExist:
                    pass
            
            return Response({
                'location': location,
                'last_updated': timezone.now().isoformat(),
                'available_incentives': incentives,
                'application_tips': [
                    'Contact local NRCS office for personalized guidance',
                    'Prepare detailed conservation plans before applying',
                    'Apply early as funding is limited and competitive',
                    'Consider combining multiple programs for maximum benefit',
                    'Keep detailed records of current practices for baseline'
                ],
                'total_potential_value': sum(
                    incentive.get('max_payment', 0) for incentive in incentives 
                    if incentive.get('type') in ['cost_share', 'grant_loan']
                )
            }, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f"Error fetching government incentives: {str(e)}")
            return Response(
                {
                    'error': 'Failed to fetch government incentives',
                    'details': str(e),
                    'available_incentives': []
                }, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


# Real-time Carbon Calculation API
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def calculate_event_carbon_impact(request):
    """
    Real-time carbon calculation API for event forms.
    Calculates carbon impact without creating database entries.
    """
    try:
        event_type = request.data.get('event_type')  # 'chemical', 'production', 'weather', 'general'
        event_data = request.data.get('event_data', {})
        
        if not event_type:
            return Response(
                {'error': 'event_type is required'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Mock calculation for now - replace with actual carbon calculator
        calculation_result = {
            'co2e': 0.1,
            'efficiency_score': 50.0,
            'usda_verified': False,
            'calculation_method': 'general_event',
            'recommendations': [],
            'event_type': event_type,
            'timestamp': timezone.now().isoformat()
        }
        
        return Response(calculation_result, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.error(f"Error calculating carbon impact: {str(e)}")
        return Response(
            {
                'error': 'Failed to calculate carbon impact',
                'details': str(e),
                'co2e': 0.0,
                'efficiency_score': 50.0,
                'usda_verified': False
            }, 
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


class CarbonCertificationViewSet(viewsets.ModelViewSet):
    queryset = CarbonCertification.objects.all()
    serializer_class = CarbonCertificationSerializer
    permission_classes = [permissions.IsAuthenticated]


class CarbonBenchmarkViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = CarbonBenchmark.objects.all()
    serializer_class = CarbonBenchmarkSerializer
    permission_classes = [permissions.IsAuthenticated]


class CarbonReportViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = CarbonReport.objects.all()
    serializer_class = CarbonReportSerializer
    permission_classes = [permissions.IsAuthenticated]


class SustainabilityBadgeViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = SustainabilityBadge.objects.all()
    serializer_class = SustainabilityBadgeSerializer
    permission_classes = [permissions.IsAuthenticated]


class MicroOffsetViewSet(viewsets.ModelViewSet):
    queryset = MicroOffset.objects.all()
    serializer_class = MicroOffsetSerializer
    permission_classes = [permissions.IsAuthenticated]


class GreenPointsViewSet(viewsets.ModelViewSet):
    queryset = GreenPoints.objects.all()
    serializer_class = GreenPointsSerializer
    permission_classes = [permissions.IsAuthenticated]


class CarbonAuditLogViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = CarbonAuditLog.objects.all()
    serializer_class = CarbonAuditLogSerializer
    permission_classes = [permissions.IsAuthenticated]


class CarbonOffsetProjectViewSet(viewsets.ModelViewSet):
    queryset = CarbonOffsetProject.objects.all()
    serializer_class = CarbonOffsetProjectSerializer
    permission_classes = [permissions.IsAuthenticated]


class CarbonOffsetPurchaseViewSet(viewsets.ModelViewSet):
    queryset = CarbonOffsetPurchase.objects.all()
    serializer_class = CarbonOffsetPurchaseSerializer
    permission_classes = [permissions.IsAuthenticated]


class CarbonOffsetCertificateViewSet(viewsets.ModelViewSet):
    queryset = CarbonOffsetCertificate.objects.all()
    serializer_class = CarbonOffsetCertificateSerializer
    permission_classes = [permissions.IsAuthenticated]


class CarbonFootprintCalculatorViewSet(viewsets.ViewSet):
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=False, methods=['post'])
    def calculate(self, request):
        """Calculate carbon footprint"""
        return Response({'co2e': 0.1}, status=status.HTTP_200_OK)


# Placeholder ViewSets for missing ones referenced in URLs
class CarbonEstablishmentSummaryViewSet(viewsets.ViewSet):
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=True, methods=['get'])
    def summary(self, request, pk=None):
        return Response({'message': 'Establishment summary'}, status=status.HTTP_200_OK)


class CarbonProductionSummaryViewSet(viewsets.ViewSet):
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=True, methods=['get'])
    def summary(self, request, pk=None):
        return Response({'message': 'Production summary'}, status=status.HTTP_200_OK)


class PublicProductionViewSet(viewsets.ViewSet):
    permission_classes = []

    @action(detail=True, methods=['get'], url_path='qr-summary')
    def qr_summary(self, request, pk=None):
        return Response({'message': 'QR summary'}, status=status.HTTP_200_OK)


class CarbonOffsetViewSet(viewsets.ViewSet):
    permission_classes = []

    def create(self, request):
        return Response({'success': True}, status=status.HTTP_201_CREATED)


class ProductionSerializer(serializers.ModelSerializer):
    class Meta:
        model = History
        fields = ['id', 'name', 'start_date', 'finish_date', 'published']


class CarbonProductionViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = History.objects.all()
    permission_classes = []
    serializer_class = ProductionSerializer


# IoT Integration and Automation Endpoints
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def john_deere_webhook(request):
    """
    Webhook endpoint for John Deere IoT fuel sensor data.
    Automatically creates equipment events and calculates carbon impact.
    """
    try:
        data = request.data
        
        # Validate required fields
        required_fields = ['device_id', 'establishment_id', 'fuel_liters', 'timestamp', 'equipment_type']
        for field in required_fields:
            if field not in data:
                return Response(
                    {'error': f'Missing required field: {field}'},
                    status=status.HTTP_400_BAD_REQUEST
                )
        
        establishment_id = data['establishment_id']
        fuel_liters = float(data['fuel_liters'])
        equipment_type = data['equipment_type']
        device_id = data['device_id']
        timestamp = data['timestamp']
        
        # Verify establishment exists
        try:
            establishment = Establishment.objects.get(id=establishment_id)
        except Establishment.DoesNotExist:
            return Response(
                {'error': 'Establishment not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        
        # Calculate carbon emissions (diesel: 2.7 kg CO2e/liter)
        co2e_emissions = fuel_liters * 2.7
        
        # Create carbon entry automatically
        carbon_entry = CarbonEntry.objects.create(
            establishment_id=establishment_id,
            type='emission',
            source=f'{equipment_type.title()} Fuel Consumption',
            amount=co2e_emissions,
            year=timezone.now().year,
            description=f'Auto-logged from IoT device {device_id}: {fuel_liters}L fuel consumed',
            created_by=request.user
        )
        
        # Log the IoT data ingestion
        CarbonAuditLog.objects.create(
            carbon_entry=carbon_entry,
            user=request.user,
            action='iot_create',
            details=f'IoT device {device_id} auto-created fuel consumption event: {fuel_liters}L = {co2e_emissions:.2f} kg CO2e'
        )
        
        return Response({
            'status': 'success',
            'carbon_entry_id': carbon_entry.id,
            'co2e_calculated': co2e_emissions,
            'message': f'Successfully processed {fuel_liters}L fuel consumption from {equipment_type}'
        }, status=status.HTTP_201_CREATED)

    except ValueError as e:
        return Response(
            {'error': f'Invalid data format: {str(e)}'}, 
            status=status.HTTP_400_BAD_REQUEST
        )
    except Exception as e:
        logger.error(f"Error processing John Deere webhook: {str(e)}")
        return Response(
            {'error': 'Failed to process IoT data'}, 
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def weather_station_webhook(request):
    """
    Webhook endpoint for weather station data.
    Auto-suggests events based on weather conditions.
    """
    try:
        data = request.data
        
        # Validate required fields
        required_fields = ['station_id', 'establishment_id', 'temperature', 'humidity', 'wind_speed', 'timestamp']
        for field in required_fields:
            if field not in data:
                return Response(
                    {'error': f'Missing required field: {field}'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
        
        establishment_id = data['establishment_id']
        temperature = float(data['temperature'])
        humidity = float(data['humidity'])
        wind_speed = float(data['wind_speed'])
        station_id = data['station_id']
        
        # Verify establishment exists
        try:
            establishment = Establishment.objects.get(id=establishment_id)
        except Establishment.DoesNotExist:
            return Response(
                {'error': 'Establishment not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        
        # Generate weather-based recommendations
        recommendations = []
        
        # High temperature alert (>35°C)
        if temperature > 35:
            recommendations.append({
                'type': 'weather_alert',
                'priority': 'high',
                'message': f'High temperature alert: {temperature}°C - Consider crop protection measures',
                'suggested_actions': [
                    'Increase irrigation frequency',
                    'Apply shade cloth if available',
                    'Monitor plant stress indicators'
                ]
            })
        
        # High wind alert (>25 km/h)
        if wind_speed > 25:
            recommendations.append({
                'type': 'weather_alert',
                'priority': 'medium',
                'message': f'High wind alert: {wind_speed} km/h - Avoid chemical applications',
                'suggested_actions': [
                    'Postpone spraying operations',
                    'Secure loose equipment',
                    'Check irrigation systems for damage'
                ]
            })
        
        # Low humidity alert (<30%)
        if humidity < 30:
            recommendations.append({
                'type': 'weather_alert',
                'priority': 'medium',
                'message': f'Low humidity alert: {humidity}% - Increase irrigation',
                'suggested_actions': [
                    'Increase irrigation duration',
                    'Monitor soil moisture levels',
                    'Consider misting systems'
                ]
            })
        
        # Log weather data processing
        CarbonAuditLog.objects.create(
            user=request.user,
            action='weather_processed',
            details=f'Weather station {station_id} data processed: {temperature}°C, {humidity}% humidity, {wind_speed} km/h wind'
        )
        
        return Response({
            'status': 'success',
            'recommendations': recommendations,
            'weather_data': {
                'temperature': temperature,
                'humidity': humidity,
                'wind_speed': wind_speed
            },
            'message': f'Weather data processed successfully with {len(recommendations)} recommendations'
        }, status=status.HTTP_200_OK)
        
    except ValueError as e:
        return Response(
            {'error': f'Invalid data format: {str(e)}'}, 
            status=status.HTTP_400_BAD_REQUEST
        )
    except Exception as e:
        logger.error(f"Error processing weather station webhook: {str(e)}")
        return Response(
            {'error': 'Failed to process weather data'}, 
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


class IoTDeviceViewSet(viewsets.ViewSet):
    """
    ViewSet for IoT device management and monitoring.
    """
    permission_classes = [permissions.IsAuthenticated]

    def list(self, request):
        """List all IoT devices for an establishment."""
        establishment_id = request.query_params.get('establishment_id')

        if not establishment_id:
            return Response(
                {'error': 'establishment_id is required'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            devices = IoTDevice.objects.filter(establishment_id=establishment_id)
            device_data = []
            
            for device in devices:
                device_info = {
                    'id': device.id,
                    'device_id': device.device_id,
                    'device_type': device.device_type,
                    'name': device.name,
                    'manufacturer': device.manufacturer,
                    'model': device.model,
                    'status': device.status,
                    'battery_level': device.battery_level,
                    'location': {
                        'lat': float(device.latitude) if device.latitude else None,
                        'lng': float(device.longitude) if device.longitude else None
                    },
                    'installed_date': device.installed_date.isoformat(),
                    'last_seen': device.last_seen.isoformat() if device.last_seen else None,
                    'configuration': device.configuration,
                    'notes': device.notes,
                    'needs_maintenance': device.needs_maintenance,
                    'total_data_points': device.total_data_points
                }
                device_data.append(device_info)
            
            return Response({
                'devices': device_data,
                'total_count': len(device_data)
            }, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f"Error listing IoT devices: {str(e)}")
            return Response(
                {'error': 'Failed to list devices', 'details': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    def create(self, request):
        """Register a new IoT device."""
        try:
            data = request.data
            
            # Validate required fields
            required_fields = ['device_id', 'device_type', 'establishment_id', 'name']
            for field in required_fields:
                if field not in data:
                    return Response(
                        {'error': f'Missing required field: {field}'},
                        status=status.HTTP_400_BAD_REQUEST
                    )
            
            # Check if device_id already exists
            if IoTDevice.objects.filter(device_id=data['device_id']).exists():
                return Response(
                    {'error': 'Device ID already exists'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Verify establishment exists
            try:
                establishment = Establishment.objects.get(id=data['establishment_id'])
            except Establishment.DoesNotExist:
                return Response(
                    {'error': 'Establishment not found'}, 
                    status=status.HTTP_404_NOT_FOUND
                )
            
            # Create the device
            device = IoTDevice.objects.create(
                device_id=data['device_id'],
                device_type=data['device_type'],
                establishment=establishment,
                name=data['name'],
                manufacturer=data.get('manufacturer', ''),
                model=data.get('model', ''),
                latitude=data.get('latitude'),
                longitude=data.get('longitude'),
                configuration=data.get('configuration', {}),
                notes=data.get('notes', ''),
                status='offline'  # Default to offline until first data received
            )
            
            # Log device registration
            CarbonAuditLog.objects.create(
                user=request.user,
                action='create',
                details=f'Registered new IoT device: {device.device_id} ({device.name})'
            )
            
            return Response({
                'id': device.id,
                'device_id': device.device_id,
                'message': f'Device {device.name} registered successfully',
                'status': 'registered'
            }, status=status.HTTP_201_CREATED)
            
        except Exception as e:
            logger.error(f"Error creating IoT device: {str(e)}")
            return Response(
                {'error': 'Failed to register device', 'details': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    def retrieve(self, request, pk=None):
        """Get details of a specific IoT device."""
        try:
            device = IoTDevice.objects.get(id=pk)
            
            # Get recent data points
            recent_data = IoTDataPoint.objects.filter(
                device=device
            ).order_by('-timestamp')[:10]
            
            device_data = {
                'id': device.id,
                'device_id': device.device_id,
                'device_type': device.device_type,
                'name': device.name,
                'manufacturer': device.manufacturer,
                'model': device.model,
                'status': device.status,
                'battery_level': device.battery_level,
                'location': {
                    'lat': float(device.latitude) if device.latitude else None,
                    'lng': float(device.longitude) if device.longitude else None
                },
                'installed_date': device.installed_date.isoformat(),
                'last_seen': device.last_seen.isoformat() if device.last_seen else None,
                'last_maintenance': device.last_maintenance.isoformat() if device.last_maintenance else None,
                'configuration': device.configuration,
                'notes': device.notes,
                'needs_maintenance': device.needs_maintenance,
                'total_data_points': device.total_data_points,
                'recent_data': [
                    {
                        'timestamp': dp.timestamp.isoformat(),
                        'data': dp.data,
                        'quality_score': dp.quality_score,
                        'processed': dp.processed
                    } for dp in recent_data
                ]
            }
            
            return Response(device_data, status=status.HTTP_200_OK)
            
        except IoTDevice.DoesNotExist:
            return Response(
                {'error': 'Device not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            logger.error(f"Error retrieving IoT device: {str(e)}")
            return Response(
                {'error': 'Failed to retrieve device', 'details': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    def update(self, request, pk=None):
        """Update IoT device configuration."""
        try:
            device = IoTDevice.objects.get(id=pk)
            data = request.data
            
            # Update allowed fields
            updatable_fields = [
                'name', 'manufacturer', 'model', 'latitude', 'longitude',
                'configuration', 'notes', 'status'
            ]
            
            updated_fields = []
            for field in updatable_fields:
                if field in data:
                    setattr(device, field, data[field])
                    updated_fields.append(field)
            
            if updated_fields:
                device.save(update_fields=updated_fields)
                
                # Log device update
                CarbonAuditLog.objects.create(
                    user=request.user,
                    action='update',
                    details=f'Updated IoT device {device.device_id}: {", ".join(updated_fields)}'
                )
            
            return Response({
                'id': device.id,
                'device_id': device.device_id,
                'message': f'Device {device.name} updated successfully',
                'updated_fields': updated_fields
            }, status=status.HTTP_200_OK)
            
        except IoTDevice.DoesNotExist:
            return Response(
                {'error': 'Device not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            logger.error(f"Error updating IoT device: {str(e)}")
            return Response(
                {'error': 'Failed to update device', 'details': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    def destroy(self, request, pk=None):
        """Delete an IoT device."""
        try:
            device = IoTDevice.objects.get(id=pk)
            device_name = device.name
            device_id = device.device_id
            
            # Log device deletion before deleting
            CarbonAuditLog.objects.create(
                user=request.user,
                action='delete',
                details=f'Deleted IoT device: {device_id} ({device_name})'
            )
            
            device.delete()
            
            return Response({
                'message': f'Device {device_name} deleted successfully'
            }, status=status.HTTP_200_OK)
            
        except IoTDevice.DoesNotExist:
            return Response(
                {'error': 'Device not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            logger.error(f"Error deleting IoT device: {str(e)}")
            return Response(
                {'error': 'Failed to delete device', 'details': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    @action(detail=False, methods=['get'])
    def device_status(self, request):
        """Get status of all IoT devices for an establishment."""
        establishment_id = request.query_params.get('establishment_id')
        
        if not establishment_id:
            return Response(
                {'error': 'establishment_id is required'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Query real IoT devices from database
            devices = IoTDevice.objects.filter(establishment_id=establishment_id)
            
            device_data = []
            for device in devices:
                # Count data points for today
                today = timezone.now().date()
                data_points_today = IoTDataPoint.objects.filter(
                    device=device,
                    timestamp__date=today
                ).count()
                
                # Determine signal strength based on last seen
                signal_strength = 'offline'
                if device.last_seen:
                    time_diff = timezone.now() - device.last_seen
                    if time_diff < timedelta(minutes=5):
                        signal_strength = 'excellent'
                    elif time_diff < timedelta(minutes=15):
                        signal_strength = 'strong'
                    elif time_diff < timedelta(hours=1):
                        signal_strength = 'weak'
                    else:
                        signal_strength = 'offline'
                
                # Build device status object
                device_info = {
                    'device_id': device.device_id,
                    'device_type': device.device_type,
                    'equipment': f"{device.manufacturer} {device.model}".strip() or device.name,
                    'status': device.status,
                    'last_update': device.last_seen.isoformat() if device.last_seen else None,
                    'battery_level': device.battery_level or 0,
                    'signal_strength': signal_strength,
                    'data_points_today': data_points_today,
                    'location': {
                        'lat': float(device.latitude) if device.latitude else None,
                        'lng': float(device.longitude) if device.longitude else None
                    },
                    'name': device.name,
                    'manufacturer': device.manufacturer,
                    'model': device.model,
                    'installed_date': device.installed_date.isoformat(),
                    'needs_maintenance': device.needs_maintenance,
                    'total_data_points': device.total_data_points,
                    'last_data_received': device.last_data_received.isoformat() if device.last_data_received else None
                }
                device_data.append(device_info)
            
            # Calculate summary statistics
            total_devices = len(device_data)
            online_devices = len([d for d in device_data if d['status'] == 'online'])
            offline_devices = len([d for d in device_data if d['status'] == 'offline'])
            maintenance_devices = len([d for d in device_data if d.get('needs_maintenance', False)])
            low_battery_devices = len([d for d in device_data if d['battery_level'] and d['battery_level'] < 20])
            
            return Response({
                'establishment_id': establishment_id,
                'devices': device_data,
                'summary': {
                    'total_devices': total_devices,
                    'online_devices': online_devices,
                    'offline_devices': offline_devices,
                    'maintenance_devices': maintenance_devices,
                    'low_battery_devices': low_battery_devices,
                    'total_data_points_today': sum(d['data_points_today'] for d in device_data)
                },
                'last_updated': timezone.now().isoformat()
            }, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f"Error fetching IoT device status: {str(e)}")
            return Response(
                {'error': 'Failed to fetch device status', 'details': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    @action(detail=False, methods=['get'])
    def device_types(self, request):
        """Get available device types for registration."""
        return Response({
            'device_types': [
                {'value': choice[0], 'label': choice[1]} 
                for choice in IoTDevice.DEVICE_TYPES
            ]
        }, status=status.HTTP_200_OK)

    @action(detail=False, methods=['post'])
    def simulate_data(self, request):
        """Simulate IoT data for testing purposes."""
        establishment_id = request.data.get('establishment_id')
        device_type = request.data.get('device_type', 'fuel_sensor')
        
        if not establishment_id:
            return Response(
                {'error': 'establishment_id is required'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        if device_type == 'fuel_sensor':
            # Simulate John Deere fuel sensor data
            simulated_data = {
                'device_id': 'JD_TRACTOR_SIM_001',
                'establishment_id': establishment_id,
                'fuel_liters': round(12.5 + (timezone.now().hour * 0.8), 2),  # Realistic fuel consumption
                'timestamp': timezone.now().isoformat(),
                'equipment_type': 'tractor',
                'engine_hours': round(timezone.now().hour * 1.2, 1),
                'location': {'lat': 40.7128, 'lng': -74.0060}
            }
            
            # Process through John Deere webhook
            webhook_response = john_deere_webhook(request._request)
            webhook_response.data['simulated_data'] = simulated_data
            
            return webhook_response
            
        elif device_type == 'weather_station':
            # Simulate weather station data
            import random
            simulated_data = {
                'station_id': 'WS_SIM_001',
                'establishment_id': establishment_id,
                'temperature': round(20 + random.uniform(-5, 15), 1),
                'humidity': round(50 + random.uniform(-20, 30), 1),
                'wind_speed': round(random.uniform(0, 35), 1),
                'timestamp': timezone.now().isoformat(),
                'pressure': round(1013 + random.uniform(-20, 20), 1)
            }
            
            # Process through weather webhook
            original_data = request.data
            request.data.update(simulated_data)
            webhook_response = weather_station_webhook(request)
            request.data = original_data  # Restore original data
            
            webhook_response.data['simulated_data'] = simulated_data
            return webhook_response
        
        else:
            return Response(
                {'error': f'Unsupported device type: {device_type}'}, 
                status=status.HTTP_400_BAD_REQUEST
            )


class AutomationRuleViewSet(viewsets.ViewSet):
    """
    ViewSet for managing automation rules that generate events from IoT data.
    """
    permission_classes = [permissions.IsAuthenticated]

    def list(self, request):
        """List automation rules for an establishment."""
        establishment_id = request.query_params.get('establishment_id')
        
        if not establishment_id:
            return Response(
                {'error': 'establishment_id is required'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            rules = AutomationRule.objects.filter(establishment_id=establishment_id)
            
            rule_data = []
            for rule in rules:
                rule_info = {
                    'id': rule.id,
                    'name': rule.name,
                    'device_type': rule.device_type,
                    'trigger_type': rule.trigger_type,
                    'trigger_config': rule.trigger_config,
                    'action_type': rule.action_type,
                    'action_config': rule.action_config,
                    'is_active': rule.is_active,
                    'last_triggered': rule.last_triggered.isoformat() if rule.last_triggered else None,
                    'trigger_count': rule.trigger_count,
                    'description': rule.description,
                    'created_at': rule.created_at.isoformat()
                }
                rule_data.append(rule_info)
        
            return Response({
                'rules': rule_data,
                'total_count': len(rule_data)
            }, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f"Error listing automation rules: {str(e)}")
            return Response(
                {'error': 'Failed to list automation rules', 'details': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    def create(self, request):
        """Create a new automation rule."""
        try:
            data = request.data
            
            # Validate required fields
            required_fields = ['name', 'establishment_id', 'trigger_type', 'trigger_config', 'action_type', 'action_config']
            for field in required_fields:
                if field not in data:
                    return Response(
                        {'error': f'Missing required field: {field}'},
                        status=status.HTTP_400_BAD_REQUEST
                    )
            
            # Verify establishment exists
            try:
                establishment = Establishment.objects.get(id=data['establishment_id'])
            except Establishment.DoesNotExist:
                return Response(
                    {'error': 'Establishment not found'}, 
                    status=status.HTTP_404_NOT_FOUND
                )
            
            # Create the automation rule
            rule = AutomationRule.objects.create(
                name=data['name'],
                establishment=establishment,
                device_type=data.get('device_type', ''),
                trigger_type=data['trigger_type'],
                trigger_config=data['trigger_config'],
                action_type=data['action_type'],
                action_config=data['action_config'],
                description=data.get('description', ''),
                created_by=request.user,
                is_active=data.get('is_active', True)
            )
            
            # Log rule creation
            CarbonAuditLog.objects.create(
                user=request.user,
                action='create',
                details=f'Created automation rule: {rule.name}'
            )
            
            return Response({
                'id': rule.id,
                'name': rule.name,
                'message': f'Automation rule {rule.name} created successfully'
            }, status=status.HTTP_201_CREATED)
            
        except Exception as e:
            logger.error(f"Error creating automation rule: {str(e)}")
            return Response(
                {'error': 'Failed to create automation rule', 'details': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    @action(detail=False, methods=['get'])
    def pending_events(self, request):
        """Get pending events that need user approval before creation."""
        establishment_id = request.query_params.get('establishment_id')
        
        if not establishment_id:
            return Response(
                {'error': 'establishment_id is required'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Get unprocessed IoT data points that could generate events
            unprocessed_data = IoTDataPoint.objects.filter(
                device__establishment_id=establishment_id,
                processed=False,
                timestamp__gte=timezone.now() - timedelta(hours=24)  # Last 24 hours
            ).order_by('-timestamp')[:20]
            
            pending_events = []
            for data_point in unprocessed_data:
                device = data_point.device
                
                # Generate event suggestions based on device type and data
                if device.device_type == 'fuel_sensor' and 'fuel_liters' in data_point.data:
                    fuel_liters = data_point.data['fuel_liters']
                    co2e_emissions = fuel_liters * 2.7  # Diesel emission factor
                    
                    pending_events.append({
                        'id': f'fuel_{data_point.id}',
                        'data_point_id': data_point.id,
                        'device_id': device.device_id,
                        'device_name': device.name,
                        'event_type': 'fuel_consumption',
                        'suggested_carbon_entry': {
                            'type': 'emission',
                            'source': f'{device.name} Fuel Consumption',
                            'amount': co2e_emissions,
                            'description': f'Fuel consumption: {fuel_liters}L from {device.name}',
                            'raw_data': data_point.data
                        },
                        'timestamp': data_point.timestamp.isoformat(),
                        'confidence': 0.95,
                        'auto_approve_recommended': fuel_liters < 50  # Auto-approve small amounts
                    })
                
                elif device.device_type == 'soil_moisture' and 'moisture_level' in data_point.data:
                    moisture = data_point.data['moisture_level']
                    
                    if moisture < 30:  # Low moisture threshold
                        pending_events.append({
                            'id': f'irrigation_{data_point.id}',
                            'data_point_id': data_point.id,
                            'device_id': device.device_id,
                            'device_name': device.name,
                            'event_type': 'irrigation_needed',
                            'suggested_action': {
                                'type': 'irrigation',
                                'priority': 'high' if moisture < 20 else 'medium',
                                'description': f'Low soil moisture detected: {moisture}% - Irrigation recommended',
                                'estimated_water_needed': '50-100L per hectare'
                            },
                            'timestamp': data_point.timestamp.isoformat(),
                            'confidence': 0.85,
                            'auto_approve_recommended': False  # Always require approval for irrigation
                        })
            
            return Response({
                'establishment_id': establishment_id,
                'pending_events': pending_events,
                'total_count': len(pending_events),
                'last_updated': timezone.now().isoformat()
            }, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f"Error fetching pending events: {str(e)}")
            return Response(
                {'error': 'Failed to fetch pending events', 'details': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    @action(detail=False, methods=['post'])
    def approve_event(self, request):
        """Approve a pending event and create the carbon entry."""
        try:
            data = request.data
            data_point_id = data.get('data_point_id')
            event_data = data.get('event_data')
            
            if not data_point_id or not event_data:
                return Response(
                    {'error': 'data_point_id and event_data are required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Get the data point
            try:
                data_point = IoTDataPoint.objects.get(id=data_point_id)
            except IoTDataPoint.DoesNotExist:
                return Response(
                    {'error': 'Data point not found'}, 
                    status=status.HTTP_404_NOT_FOUND
                )
            
            # Find or create a CarbonSource for IoT-generated events
            source_name = event_data.get('source', 'IoT Device Data')
            carbon_source, created = CarbonSource.objects.get_or_create(
                name=source_name,
                defaults={
                    'category': 'equipment',
                    'emission_factor': 2.7,  # Default diesel emission factor
                    'unit': 'kg CO2e/L',
                    'description': f'Automatically created for IoT device: {data_point.device.device_id}'
                }
            )
            
            # Create the carbon entry
            carbon_entry = CarbonEntry.objects.create(
                establishment=data_point.device.establishment,
                type=event_data['type'],
                source=carbon_source,  # Use CarbonSource instance instead of string
                amount=event_data['amount'],
                year=timezone.now().year,
                description=event_data['description'],
                iot_device_id=data_point.device.device_id,
                created_by=request.user
            )
            
            # Mark data point as processed
            data_point.processed = True
            data_point.processed_at = timezone.now()
            data_point.carbon_entry = carbon_entry
            data_point.save()
            
            # Update device data point counter
            data_point.device.increment_data_points()
            
            # Log the approval
            CarbonAuditLog.objects.create(
                carbon_entry=carbon_entry,
                user=request.user,
                action='iot_approve',
                details=f'Approved IoT event from {data_point.device.device_id}: {event_data["amount"]:.2f} kg CO2e'
            )
            
            return Response({
                'carbon_entry_id': carbon_entry.id,
                'message': 'Event approved and carbon entry created successfully',
                'co2e_amount': carbon_entry.amount,
                'source_created': created
            }, status=status.HTTP_201_CREATED)
            
        except Exception as e:
            logger.error(f"Error approving event: {str(e)}")
            return Response(
                {'error': 'Failed to approve event', 'details': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    @action(detail=False, methods=['post'])
    def reject_event(self, request):
        """Reject a pending event and mark data point as processed without creating entry."""
        try:
            data_point_id = request.data.get('data_point_id')
            reason = request.data.get('reason', 'User rejected')
            
            if not data_point_id:
                return Response(
                    {'error': 'data_point_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Get the data point
            try:
                data_point = IoTDataPoint.objects.get(id=data_point_id)
            except IoTDataPoint.DoesNotExist:
                return Response(
                    {'error': 'Data point not found'}, 
                    status=status.HTTP_404_NOT_FOUND
                )
            
            # Mark as processed without creating carbon entry
            data_point.processed = True
            data_point.processed_at = timezone.now()
            data_point.save()
            
            # Log the rejection
            CarbonAuditLog.objects.create(
                user=request.user,
                action='iot_reject',
                details=f'Rejected IoT event from {data_point.device.device_id}: {reason}'
            )
            
            return Response({
                'message': 'Event rejected successfully',
                'reason': reason
            }, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f"Error rejecting event: {str(e)}")
            return Response(
                {'error': 'Failed to reject event', 'details': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


# Placeholder ViewSets for missing ones referenced in URLs